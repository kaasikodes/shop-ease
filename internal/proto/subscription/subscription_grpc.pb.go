// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.1
// source: proto/subscription.proto

package subscription

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SubscriptionService_CreateVendorSubscription_FullMethodName       = "/subscription.SubscriptionService/CreateVendorSubscription"
	SubscriptionService_MarkVendorSubscriptionAsPaid_FullMethodName   = "/subscription.SubscriptionService/MarkVendorSubscriptionAsPaid"
	SubscriptionService_VerifyVendorSubscriptionStatus_FullMethodName = "/subscription.SubscriptionService/VerifyVendorSubscriptionStatus"
)

// SubscriptionServiceClient is the client API for SubscriptionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SubscriptionServiceClient interface {
	// Begin here -> create plan(will have an audit history to track modifications), subscribeVendor(planId, vendorId, userId)
	// events  -> will be emitted to track the user activity/interactions per vendor e.g if a user has items that belongs to the vendor store in their order that will be recorded as a user.ordered_ordered_from_store interaction, if they add an item to their cart/wishlist user.showed_interest_in_item_from_store each of this will have a timestamp, now they will be a formula that will be dynamically calculated everytime a request is made to the VerifyVendorSubscriptionStatus checking against current subscription plan so once the subscription limit is reached it will return {isValid: false, message: "Subscription Limit has been exceeded" | "Subscription has expired for this month ..."}, if subscription limit has been exceeded it will updated (limit_exceeded_at) for the subscription and an email will be sent to the user, also subsequent checks will first check this before proceeding to calculate so it has to only send the mail the first time it notices the issue, notify when they have reached 3/4 of their user limit. The check should be against all plans of the vendor that are not expired or limit_exceeded so can aggregrate and decide what to permit - in the event of upgrades, (no subscription cancellations?)
	CreateVendorSubscription(ctx context.Context, in *CreateVendorSubscriptionRequest, opts ...grpc.CallOption) (*VendorSubscription, error)
	MarkVendorSubscriptionAsPaid(ctx context.Context, in *MarkVendorSubscriptionAsPaidRequest, opts ...grpc.CallOption) (*VendorSubscription, error)
	VerifyVendorSubscriptionStatus(ctx context.Context, in *VerifyVendorSubscriptionStatusRequest, opts ...grpc.CallOption) (*VerifyVendorSubscriptionStatusResponse, error)
}

type subscriptionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSubscriptionServiceClient(cc grpc.ClientConnInterface) SubscriptionServiceClient {
	return &subscriptionServiceClient{cc}
}

func (c *subscriptionServiceClient) CreateVendorSubscription(ctx context.Context, in *CreateVendorSubscriptionRequest, opts ...grpc.CallOption) (*VendorSubscription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VendorSubscription)
	err := c.cc.Invoke(ctx, SubscriptionService_CreateVendorSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionServiceClient) MarkVendorSubscriptionAsPaid(ctx context.Context, in *MarkVendorSubscriptionAsPaidRequest, opts ...grpc.CallOption) (*VendorSubscription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VendorSubscription)
	err := c.cc.Invoke(ctx, SubscriptionService_MarkVendorSubscriptionAsPaid_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionServiceClient) VerifyVendorSubscriptionStatus(ctx context.Context, in *VerifyVendorSubscriptionStatusRequest, opts ...grpc.CallOption) (*VerifyVendorSubscriptionStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyVendorSubscriptionStatusResponse)
	err := c.cc.Invoke(ctx, SubscriptionService_VerifyVendorSubscriptionStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubscriptionServiceServer is the server API for SubscriptionService service.
// All implementations must embed UnimplementedSubscriptionServiceServer
// for forward compatibility.
type SubscriptionServiceServer interface {
	// Begin here -> create plan(will have an audit history to track modifications), subscribeVendor(planId, vendorId, userId)
	// events  -> will be emitted to track the user activity/interactions per vendor e.g if a user has items that belongs to the vendor store in their order that will be recorded as a user.ordered_ordered_from_store interaction, if they add an item to their cart/wishlist user.showed_interest_in_item_from_store each of this will have a timestamp, now they will be a formula that will be dynamically calculated everytime a request is made to the VerifyVendorSubscriptionStatus checking against current subscription plan so once the subscription limit is reached it will return {isValid: false, message: "Subscription Limit has been exceeded" | "Subscription has expired for this month ..."}, if subscription limit has been exceeded it will updated (limit_exceeded_at) for the subscription and an email will be sent to the user, also subsequent checks will first check this before proceeding to calculate so it has to only send the mail the first time it notices the issue, notify when they have reached 3/4 of their user limit. The check should be against all plans of the vendor that are not expired or limit_exceeded so can aggregrate and decide what to permit - in the event of upgrades, (no subscription cancellations?)
	CreateVendorSubscription(context.Context, *CreateVendorSubscriptionRequest) (*VendorSubscription, error)
	MarkVendorSubscriptionAsPaid(context.Context, *MarkVendorSubscriptionAsPaidRequest) (*VendorSubscription, error)
	VerifyVendorSubscriptionStatus(context.Context, *VerifyVendorSubscriptionStatusRequest) (*VerifyVendorSubscriptionStatusResponse, error)
	mustEmbedUnimplementedSubscriptionServiceServer()
}

// UnimplementedSubscriptionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSubscriptionServiceServer struct{}

func (UnimplementedSubscriptionServiceServer) CreateVendorSubscription(context.Context, *CreateVendorSubscriptionRequest) (*VendorSubscription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVendorSubscription not implemented")
}
func (UnimplementedSubscriptionServiceServer) MarkVendorSubscriptionAsPaid(context.Context, *MarkVendorSubscriptionAsPaidRequest) (*VendorSubscription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkVendorSubscriptionAsPaid not implemented")
}
func (UnimplementedSubscriptionServiceServer) VerifyVendorSubscriptionStatus(context.Context, *VerifyVendorSubscriptionStatusRequest) (*VerifyVendorSubscriptionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyVendorSubscriptionStatus not implemented")
}
func (UnimplementedSubscriptionServiceServer) mustEmbedUnimplementedSubscriptionServiceServer() {}
func (UnimplementedSubscriptionServiceServer) testEmbeddedByValue()                             {}

// UnsafeSubscriptionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SubscriptionServiceServer will
// result in compilation errors.
type UnsafeSubscriptionServiceServer interface {
	mustEmbedUnimplementedSubscriptionServiceServer()
}

func RegisterSubscriptionServiceServer(s grpc.ServiceRegistrar, srv SubscriptionServiceServer) {
	// If the following call pancis, it indicates UnimplementedSubscriptionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SubscriptionService_ServiceDesc, srv)
}

func _SubscriptionService_CreateVendorSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVendorSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).CreateVendorSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubscriptionService_CreateVendorSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).CreateVendorSubscription(ctx, req.(*CreateVendorSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionService_MarkVendorSubscriptionAsPaid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkVendorSubscriptionAsPaidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).MarkVendorSubscriptionAsPaid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubscriptionService_MarkVendorSubscriptionAsPaid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).MarkVendorSubscriptionAsPaid(ctx, req.(*MarkVendorSubscriptionAsPaidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionService_VerifyVendorSubscriptionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyVendorSubscriptionStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).VerifyVendorSubscriptionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubscriptionService_VerifyVendorSubscriptionStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).VerifyVendorSubscriptionStatus(ctx, req.(*VerifyVendorSubscriptionStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SubscriptionService_ServiceDesc is the grpc.ServiceDesc for SubscriptionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SubscriptionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "subscription.SubscriptionService",
	HandlerType: (*SubscriptionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVendorSubscription",
			Handler:    _SubscriptionService_CreateVendorSubscription_Handler,
		},
		{
			MethodName: "MarkVendorSubscriptionAsPaid",
			Handler:    _SubscriptionService_MarkVendorSubscriptionAsPaid_Handler,
		},
		{
			MethodName: "VerifyVendorSubscriptionStatus",
			Handler:    _SubscriptionService_VerifyVendorSubscriptionStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/subscription.proto",
}
